// JSON 过滤器的实现

pub enum Filter {
  Identity
  ObjectIdentifier(String)
  ArrayIndex(Int)
  Pipe(Filter, Filter)
  Array(Array[Filter])
  Object(Array[(String, Filter)])
  Optional(Filter)
  Alternative(Filter, Filter)
  Slice(Option[Int], Option[Int], Option[Int])
}

fn normalize_index(index: Int, len: Int) -> Int {
  if index < 0 {
    if len + index < 0 { 0 } else { len + index }
  } else if index > len {
    len
  } else {
    index
  }
}

fn is_null(value: parser.JsonValue) -> Bool {
  match value {
    parser.JsonValue::Null => true
    _ => false
  }
}

fn eval_filter(f: Filter, input: parser.JsonValue) -> parser.JsonValue {
  match f {
    Identity => input

    ObjectIdentifier(field) => match input {
      parser.JsonValue::Object(obj) => match obj.get(field) {
        Some(v) => v
        None => parser.json_null()
      }
      _ => parser.json_null()
    }

    ArrayIndex(idx) => match input {
      parser.JsonValue::Array(arr) => {
        if idx >= 0 && idx < arr.length() {
          arr[idx]
        } else {
          parser.json_null()
        }
      }
      _ => parser.JsonValue::Null
    }

    Pipe(a, b) => eval_filter(b, eval_filter(a, input))

    Array(filters) => {
      let array_out = Array::new()
      let i = 0
      while i < filters.length() {
        array_out.push(eval_filter(filters[i], input))
        i = i + 1
      }
      parser.json_array(array_out)
    }

    Object(pairs) => {
      let object_map = @builtin.Map::new()
      let i = 0
      while i < pairs.length() {
        let (key, f2) = pairs[i]
        object_map.set(key, eval_filter(f2, input))
        i = i + 1
      }
      parser.json_object(object_map)
    }

    Optional(inner) => {
      let opt_result = eval_filter(inner, input)
      if is_null(opt_result) { parser.json_null() } else { opt_result }
    }

    Alternative(a, b) => {
      let alt_result = eval_filter(a, input)
      if is_null(alt_result) { eval_filter(b, input) } else { alt_result }
    }

    Slice(start, end, step) => match input {
      parser.JsonValue::Array(arr) => {
        let len = arr.length()
        let s = match start { Some(idx) => normalize_index(idx, len) None => 0 }
        let e = match end { Some(idx) => normalize_index(idx, len) None => len }
        let stp = match step { Some(n) => n None => 1 }
        if stp == 0 { return parser.json_null() }
        let slice_out = Array::new()
        let mut i = s
        while (stp > 0 && i < e) || (stp < 0 && i > e) {
          if i >= 0 && i < len { slice_out.push(arr[i]) }
          i = i + stp
        }
        parser.json_array(slice_out)
      }
      _ => parser.json_null()
    }
  }
}

pub fn identity() -> Filter { Identity }

pub fn object_identifier(name: String) -> Filter { ObjectIdentifier(name) }

pub fn array_index(index: Int) -> Filter { ArrayIndex(index) }

pub fn pipe(a: Filter, b: Filter) -> Filter { Pipe(a, b) }

pub fn array(filters: Array[Filter]) -> Filter { Array(filters) }

pub fn object(pairs: Array[(String, Filter)]) -> Filter { Object(pairs) }

pub fn optional(f: Filter) -> Filter { Optional(f) }

pub fn alternative(a: Filter, b: Filter) -> Filter { Alternative(a, b) }

pub fn slice(start: Option[Int], end: Option[Int], step: Option[Int]) -> Filter {
  Slice(start, end, step)
}

pub fn apply_filter(f: Filter, input: parser.JsonValue) -> parser.JsonValue {
  eval_filter(f, input)
}