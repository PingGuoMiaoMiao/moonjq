// Generated using `moon info`, DON'T EDIT IT
package "username/jq/cmd/lib/parser"

// Values
fn json_value(Array[(Token, Int, Int)], initial_pos? : Int) -> JsonValue raise ParseError

// Errors
pub suberror ParseError {
  UnexpectedToken(Token, (Int, Int), Array[TokenKind])
  UnexpectedEndOfInput(Int, Array[TokenKind])
}
impl Show for ParseError

// Types and methods
pub enum BinOp {
  Add
  Sub
  Mul
  Div
  Mod
  Eq
  Neq
  Lt
  Gt
  Lte
  Gte
  And
  Or
}

pub enum Expr {
  Ident
  FieldAccess(Expr, String)
  ArrayIndex(Expr, Int)
  ArrayIter(Expr)
  ObjectIter(Expr)
  Pipe(Expr, Expr)
  Literal(JsonValue)
  BinaryOp(Expr, BinOp, Expr)
  UnaryOp(UnOp, Expr)
  Conditional(Expr, Expr, Expr)
  Call(String, @list.List[Expr])
  AsBinding(Expr, String)
  VarRef(String)
  ArrayConstructor(@list.List[Expr])
  ObjectConstructor(@list.List[(String, Expr)])
}

pub enum JsonValue {
  String(String)
  Number(Double)
  Boolean(Bool)
  Null
  Object(Map[String, JsonValue])
  Arraya(Array[JsonValue])
}

pub(all) enum Token {
  STRING(String)
  NUMBER(Double)
  TRUE
  FALSE
  NULL
  LBRACE
  RBRACE
  LBRACKET
  RBRACKET
  COLON
  COMMA
}
fn Token::kind(Self) -> TokenKind
impl Eq for Token
impl Show for Token

pub(all) enum TokenKind {
  TK_STRING
  TK_NUMBER
  TK_TRUE
  TK_FALSE
  TK_NULL
  TK_LBRACE
  TK_RBRACE
  TK_LBRACKET
  TK_RBRACKET
  TK_COLON
  TK_COMMA
}
impl Show for TokenKind

pub enum UnOp {
  Neg
  Not
}

// Type aliases
pub typealias Map[String, JsonValue] as Object

// Traits

